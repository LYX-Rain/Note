# C++ Basics

C++ 是 C 语言的扩展，学习任何语言的第一个程序，输出“hello world”

```C++
#include <iostream>
using namespace std;

int main() {
    cout << "hello, world" << endl;
    return 0;
}
```

## Variables and Basic Types

### 基本内置类型

### 变量

默认初始化

如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值是什么由变量类型决定，同时也受定义变量的位置影响

定义于任何函数体之外的变量被初始化为0

定义在函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误

### compound type 复合类型

复合类型是指基于其他类型定义的类型

#### reference 引用

引用为对象起了另外一个名字，引用类型引用（refers to）另一种类型。通过将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名：

```C++
int ival = 1024;
int &refVal = ival; // refVal 指向 ival（是 ival 的另一个名字）
int $refVal2;       // 报错：引用必须初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定（bind）**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因此无法令引用重新绑定到另一个对象，因此引用必须初始化

引用即别名：引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字

定义了一个引用之后，对齐进行的所有操作都是在与之绑定的对象上进行的

#### pointer 指针

指针是“指向（point to）”另外一种类型的复合类型。
与引用不同的是
指针本身就是一个对象，允许对指针赋值或拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
指针无须在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值

### const 限定符

#### const 的引用

#### 指针和 const

#### constexpr 和常量表达式

**常量表达式**（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面量属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```C++
const int max_files = 20;           // 是
const int limit = max_files + 1;    // 是
int staff_size = 27;                // 不是
const int sz = get_size()           // 不是
```

constexpr 变量

C++ 11 允许将变量声明为 `constexpr` 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 `constexpr` 的变量一定是一个常量，而且必须用常量表达式初始化：

```C++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();      // 只有当size是一个 constexpr 函数时，才是一条正确的声明语句
```

在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关

### 处理类型

## Strings, Vectors, and Arrays

### 标准库类型 string

### 标准库类型 vector

### iterator 迭代器

可以使用下标运算符来访问 `string` 对象的字符或 `vector`对象的元素，但是还有一种更通用的机制——迭代器（iterator）
所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作

类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者 `string` 对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素。迭代器有有效和无效之分，这和指针差不多。有效的迭代器或指向某个元素，或者指向容器中尾元素的下一位置；其他情况都属于无效

####

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都有名为 `begin` 和 `end` 的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器

### 数组

## Expressions

### 成员访问运算符

点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符有关，表达式 `ptr->mem` 等价于 `(*ptr).mem`：

```C++
string s1 = "a string", *p = &s1;
auto n = s1.size();
n = (*p).size();
n = p->size();
```

因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号

### sizeof 运算符

`sizeof` 运算符返回一条表达式或一个类型名字所占的字节数。`sizeof` 运算符满足右结合律，其所得的值是一个 `size_t` 类型的常量表达式。运算符的运算对象有两种形式：

```C++
sizeof(type)
sizeof expr
```

在第二种形式中，sizeof 返回的是表达式结果类型的大小。
sizeof 并不实际计算其运算对象的值：

sizeof 运算符的结果部分地依赖于其作用的类型

- 对 `char` 或者类型为 `char` 的表达式执行，结果为1
- 对引用类型执行得到被引用对象所占空间的大小
- 对指针执行得到指针本身所占空间的大小
- 对解引用指针执行得到指针指向的对象所占空间的大小，指针不需有效
- 对数组执行得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次运算并求和。注意：sizeof 运算不会把数组转换成指针来处理
- 对 string 对象或 vector 对象执行只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

因为执行 sizeof 运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：

```C++
constexpr size_t sz = sizeof(ia) / sizeof(*ia);
int arr2[sz];
```

因为 sizeof 的返回是一个常量表达式，所以可以用  sizeof 的结果声明数组的维度

## Statements 语句

### try 语句块和异常处理

异常处理机制为为程序中异常检测和异常处理这两部分的协作提供支持。在 C++ 中，异常处理包括：

- **throw表达式**（throw expression），异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。我们说throw**引发**（raise）了异常
- **try语句块**（try block），异常处理部分使用 try 语句块处理异常。try 语句块以关键字 try 开始，并以一个或多个**catch 子句**（catch clause）结束。try 语句块中代码抛出的异常通常会被某个 catch 子句处理。因为 catch 子句“处理”异常，所以它们也被称作**异常处理代码**（exception handler）
- 一套**异常类**（exception class），用于在 throw 表达式和相关的 catch 子句之间传递异常的具体信息

#### throw 表达式

程序的异常检测部分使用 throw 表达式引发一个异常。throw 表达式包含关键字 throw 和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw 表达式后面通常紧跟着一个分号，从而构成一条表达式语句。

#### try 语句块

try 语句块的通常语法形式是

```C++
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // ...
```

#### 标准异常

C++ 标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：

- exception 头文件定义了最通用的异常类 exception。它只报告异常的发生，不提供任何额外信息
- stdexcept 头文件定义了几种常用的异常类，见下表
- new 头文件定义了 bad_alloc 异常类型
- type_info 头文件定义了 bad_cast 异常类型

| exception | 最常见的问题 |
| --- | --- |
| runtime_error | 只有在运行时才能检测出的问题 |
| range_error | 运行时错误：生成的结果超出了有意义的值域范围 |
| overflow_error | 运行时错误：计算上溢 |
| underflow_error | 运行时错误：计算下溢 |
| logic_error | 程序逻辑错误 |
| domain_error | 逻辑错误：参数对应的结果值不存在 |
| invalid_argument | 逻辑错误：无效参数 |
| length_error | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| out_of_range | 逻辑错误：使用一个超出有效范围的值 |

标准库异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型的对象赋值
我们只能以默认初始化的方式初始化 exception、bad_alloc和bad_cast 对象，不允许为这些对象提供初始值
其他类型的行为则恰好相反：应该使用 string 对象或 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息

异常类型只定义了一个名为 what 的成员函数，该函数没有任何参数，返回值是一个指向 C 风格的字符串的 const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说，what 返回的内容由编译器决定

## Funcitons 函数

函数是命名了的代码块，通过调用函数执行相应的代码

### 函数基础

一个典型的函数定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体

通过**调用运算符**（call operator）来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参（argument）列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型

### 函数指针

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关

```C++
// 比较两个 string 对象的长度
bool lengthCompare(const string&, const string&);
```

该函数的类型是 `bool(const string&, const string&)`。想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```C++
// pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型
bool (*pf)(const string&, const string&); // 未初始化
```

从声明的名字开始观察，pf 前面有个*，因此 pf 是指针；右侧是形参列表，表示  pf 指向的是函数；再观察左侧，发现函数的返回类型是布尔值

*pf 两端的括号必不可少。如果不写这对括号，则 pf 是一个返回值为 bool 指针的函数：

```C++
// 声明一个名为 pf 的函数，该函数返回 bool*
bool *pf(const string&, const string&);
```

#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动地转换成指针：

```C++
pf = lengthCompare;     // pf 指向名为 lengthCompare 的函数
pf = &lengthCompare;    // 等价的赋值语句：取地址符是可选的
```

此外，还能直接使用指向函数的指针调用该函数，无须提前解引用指针：

```C++
bool b1 = pf("hello", "goodbye");           // 调用 lengthCompare 函数
bool b2 = (*pf)("hello", "goodbye");        // 一个等价的调用
bool b3 = lengthCompare("hello", "goodbye");// 另一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。但是可以为函数指针赋一个 `nullptr` 或者值为0的整数常量表达式，表示该指针没有指向任何一个函数

## Classes

# C++ Standard Library

## The IO Library

### string stream string 流

`sstream` 头文件定义了三个类型来支持内存 IO
`istringstream` 从 string 读取数据，`ostringstream` 向 string 写入数据，`stringstream` 既可以读也可以写。
与 `fstream` 类型类似，头文件 `sstream` 中定义的类型都继承自 `iostream` 头文件中的类型。此外 `sstream` 还增加了一些成员来管理与流相关联的 string。

|                   |                                                                                  |
| ----------------- | -------------------------------------------------------------------------------- |
| *sstream* strm    | strm 是一个未绑定的 stringstream 对象                                            |
| *sstream* strm(s) | strm 是一个 *sstream* 对象，保存 string s 的一个拷贝。此构造函数是 `explicit` 的 |
| strm.str()        | 返回 strm 所保存的 string 的拷贝                                                 |
| strm.str(s)       | 将 string s 拷贝到 strm 中。返回 void                                            |

#### 使用 istringstream

当需要对整行文本和其中的每个单词进行处理时，通常可以使用 `istringstream`
例如有一个文件，列出了一些人和他们的电话号码，电话号码可以有多个：

```
morgan 4325252 34254325 145135
drew 5436362532
lee 654367 252 56756
```

首先定义一个类来描述输入数据

```C++
struct PersonInfo {
    string name;
    vector<string> phones;
}
```

读取文件，并创建一个 PersonInfo 的 vector 来保存文件中的每条记录

```c++
string line, word;
vector<PersonInfo> people;

while (getline(cin, line)) {
    PersonInfo info;
    istringstream record(line);
    record >> info.name;
    while (record >> word) {
        info.phones.push_back(word);
    }
    people.push_back(info);
}
```

使用 `getline` 从标准输入读取整行数据，在 while 中定义一个局部 PersonInfo 对象来保存当前行中的数据
将一个 `istringstream` 与刚刚读取的文本进行绑定，这样就可以在此 istringstream 上使用输入运算符来读取当前记录中的每个元素
当读取完 line 中所有数据后，内层 while 循环就结束了。

## Class 类

类的基本思想是**数据抽象**（data abstraction）和**封装**（encapsulation）。数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问是实现部分

类想要实现数据抽象和封装，需要首先定义一个**抽象数据类型**（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无需了解类型的工作细节

### 定义抽象数据类型

#### 定义成员函数

定义在类内部的函数是隐式的 `inline` 函数

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外

**引入this**

当我们调用成员函数时，实际上是在替某个对象调用它。成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化`this`

在函数内部可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为`this`所指的正是这个对象。任何对类成员的直接访问都被看作`this`的隐式引用

对于我们来说，`this`形参是隐式定义的。任何自定义名为 `this` 的参数或变量的行为都是非法的。因为 `this` 的目的总是指向“这个”对象，所以 `this` 是一个常量指针，不允许改变 `this` 中保存的地址

**引入 const 成员函数**

在成员函数的参数列表后添加 `const` 关键字，其作用是修改隐式 `this` 指针的类型

默认情况下，`this` 的类型是指向类类型非常量版本的常量指针（className *const）。尽管 `this` 是隐式的，但它仍然需要遵循初始化规则。如果成员函数不会改变 `this` 所指的对象，则应该把 `this` 声明成 `const className *const`

C++ 语法通过把 `const` 关键字放在成员函数的参数列表之后，来表示 `this` 是一个指向常量的指针。像这样使用 `const` 的成员函数被称作**常量成员函数**（const member function）

Note：常量对象，以及常量对象的引用或指针都只能调用常量成员函数

**类作用域和成员函数**

类本省就是一个作用域，类的成员函数的定义嵌套在类的作用域之内。编译器分两部处理类：首先编译成员的声明，然后才轮到成员函数体。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序

**在类的外部定义成员函数**

和其他函数一样，当在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致

```C++
double Sales_data::avg_price() const
{

}
```

函数名 `Sales_data::avg_price` 使用作用域运算符来说明：定义了一个名为 `avg_price` 的函数，并且该函数被声明在类 `Sales_data` 的作用域内

**定义一个返回 this 对象的函数**

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    return *this;
}
```

return 语句解引用 this 指针以获得执行该函数的对象

#### 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过**构造函数**（constructor）来控制其对象的初始化过程。无论何时只要类的对象被创建，就会执行构造函数

构造函数的名字和类名相同，但构造函数没有返回类型。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别

不同于其他成员函数，构造函数不能被声明成 `const` 的。当我们创建类的一个 `const` 对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在 `const` 对象的构造过程中可以向其写值

类通过**默认构造函数**（default constructor）来控制默认初始化过程。默认构造函数无须任何实参。如果没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数

编译器创建的构造函数又被称为**合成的默认构造函数**（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：

- 如果存在类内的初始值，用它来初始化成员
- 否则，*默认初始化*该成员

**某些类不能依赖于合成的默认构造函数**

合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，因为：

1. 编译器只有在类不包含任何构造函数的情况下才会生成一个默认的构造函数。一旦定义了一些其他的构造函数，那么除非再定义一个默认的构造函数，否则类将没有默认构造函数（依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制）
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在类中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的
3. 有时编译器不能为某些类合成默认的构造函数。例如，类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员

**=default的含义**

从解释默认构造函数的含义开始

```C++
Sales_data() = default;
```

首先明确一点：因为该构造函数不接受任何实参，所以它是一个默认构造函数。定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数

在 C++ 11 中，如果需要默认的行为，那么可以通过在参数列表后面写上 `= default` 来要求编译器生成构造函数。`= default` 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。如果在类的内部，则默认构造函数是内联的；如果在类的外部，则该成员默认情况下不是内联的

**构造函数初始值列表**

```C++
Sales_data(const std::string &s) : bookNo(s) {}
```

在参数列表和花括号之间的部分称为**构造函数初始化列表**（constructor initialize list），它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值

如果没有在构造函数的初始值列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化

如果成员是 `const`、引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员初始化顺序与它们在类定义中的出现顺序一致。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序

一般来说，初始化顺序没有特别要求，但如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了

```C++
class X {
    int i;
    int j;
public:
    // 未定义的：i 在 j 之前被初始化
    X(int val) : j(val), i(j) {}
};
```

最好令构造函数初始值的顺序与成员声明的顺序保持一致

如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认的构造函数

#### 委托构造函数

C++11 新标准扩展了构造函数初始值的功能，使可以定义**委托构造函数（delegating constructor）**。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些职责委托给了其他构造函数

#### 默认构造函数

当对象被默认初始化或值初始化时会自动执行默认构造函数。默认初始化在以下情况下发生：

- 当在块作用域内不适用任何初始值定义一个非静态变量或数组时
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时
- 当类类型的成员没有在构造函数初始值列表中显示地初始化时

值初始化在以下情况下发生：

- 在数组初始化过程中如果提供地初始值数量少于数组的大小时
- 当不使用初始值定义一个局部静态变量时
- 通过写形如 `T()` 的表达式显式地请求值初始化时，其中 T 是类型名（vector 的一个构造函数只接受一个实参用于说明 vector 大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）

类必须包含一个默认构造函数以便在上述情况下使用

#### 隐式的类类型转换

如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时把这种构造函数称作**转换构造函数（converting constructor）**

#### 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。
对象在几种情况下会被拷贝：初始化变量以及以值的方式传递或返回一个对象。

如果不主动定义这些操作，则编译器将替我们合成它。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作

#### 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元（friend）**
把一个函数作为它的友元只需要增加一条以 `friend` 关键字开始的函数声明即可：

友元声明只能出现在类定义的内部。友元不是类的成员也不受它所在区域访问控制级别的约束

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，那么就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中（类的外部）

### 类的其他特性

定义在类内部的成员函数自动是 `inline` 的

可变数据成员
有时希望在 const 成员函数内能修改类的某个成员函数，可以通过在变量的声明中加入 `mutable` 关键字。
一个**可变数据成员**永远不会是 const，即使它是 const 对象的成员

### 访问控制与封装

### 类的静态成员

有时类需要它的一些成员与类本身直接相关，而非与类的每个对象关联

通过在成员的声明之前加上关键字 `static` 使得其与类关联在一起。和其他成员一样，静态成员可以是 `public` 的或 `private` 的。静态数据成员的类型可以是常量、引用、指针、类类型等

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含 `this` 指针。作为结果，静态成员函数不能声明成 `const` 的

使用作用域运算符直接访问静态成员，使用类的对象、引用或者指针来访问静态成员

成员函数不用通过作用域运算符就能直接使用静态成员

和其他的成员函数一样，既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复 `static` 关键字，该关键字只出现在类内部的声明语句

因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。必须在类的外部定义和初始化每个静态成员

类似于全局变量，静态数据成员定义在任何函数之外。因此一旦被定义，就将一直存在于程序的整个生命周期中

通常情况下，类的静态成员不应该在类的内部初始化。但可以为静态成员提供 `const` 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 `constexpr`。初始值必须是常量表达式

```C++
class Account {
public:
  static double rate() { return 0; }
  static void rate(double);
private:
  static constexpr int period = 30;
  double daily_tbl[period];
};
```

如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的 `const` 或 `constexpr static` 不需要分别定义，否则，该成员必须有一条定义语句

### 运行时类型识别（RTTI）

运行时类型识别（run-time type identification，RTTI）的功能由两个运算符实现：

- typeid 运算符，用于返回表达式的类型
- dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用

将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型

这两个运算符特别适用于以下情况：想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。
一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本

然而，并非任何时候都能定义一个虚函数。假设无法使用虚函数，则可以使用一个 RTTI运算符

## Sequential Containers 顺序容器

一个容器就是一些特定类型对象的集合。**顺序容器**（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应

所有顺序容器都提供了快速顺序访问元素的能力，但是这些容器在以下方面都有不同的性能折中：

- 向容器添加或从容器中删除元素的代价
- 非顺序访问容器中元素的代价

| 容器         | 描述                                                                        |
| ------------ | --------------------------------------------------------------------------- |
| vector       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢      |
| deque        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快                     |
| list         | 双向链表。只支持双向顺序访问。在 list 中任何位置进行插入/删除操作速度都很快 |
| forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快     |
| array        | 固定大小数组。支持快速随机访问。不能添加或删除元素                          |
| string       | 与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 |

forward_list 的设计目的是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list 没有 size 操作，因为保存或计算其大小就会比手写链表多出额外的开销。对于其他容器而言，size 保证是一个快速的常量时间的操作

#### 确定使用哪种顺序容器

如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则

- 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 vector 追加数据，然后再调用 sort 函数来重排容器中的元素，从而避免再中间位置添加元素
- 如果必须在中间位置插入元素，考虑在输入阶段使用 list，一旦输入完成，将 list 中的内容拷贝到一个 vector 中

### 容器库概览

容器操作

|                                 |                                                                  |
| ------------------------------- | ---------------------------------------------------------------- |
| 类型别名                        |                                                                  |
| iterator                        | 此容器类型的迭代器类型                                           |
| const_iterator                  | 可以读取元素，但不能修改元素的迭代器类型                         |
| size_type                       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小           |
| difference                      | 带符号整数类型，足够保存两个迭代器之间的距离                     |
| value_type                      | 元素类型                                                         |
| reference                       | 元素的左值类型；与value_type& 含义相同                           |
| const_reference                 | 元素的 const 左值类型（即，const value_type&）                   |
| 构造函数                        |                                                                  |
| C c;                            | 默认构造函数                                                     |
| C c1(c2)                        | 构造 c2 的拷贝 c1                                                |
| C c(b, e)                       | 构造 c，将迭代器 b 和 e 指定范围内的元素拷贝到 c（array 不支持） |
| C c(a, b, c...)                 | 列表初始化c                                                      |
| 赋值与 swap                     |                                                                  |
| c1 = c2                         | 将c1 中的元素替换为 c2 中元素                                    |
| c1 = {a, b, c}                  | 将 c1 中的元素替换为列表中元素（不适用于 array）                 |
| a.swap(b)                       | 交换 a 和 b 的元素                                               |
| swap(a, b)                      | 与 a.swap(b) 等价                                                |
| 大小                            |                                                                  |
| c.size()                        | c 中元素的数目（不支持 forward_list）                            |
| c.max_size()                    | c 可保存的最大元素数目                                           |
| c.empty()                       | 若 c 中存储了元素，返回 false，否则返回 true                     |
| 添加/删除元素（不适用于 array） | 在不同容器中，这些操作的接口都不同                               |
| c.insert(args)                  | 将 args 中的元素拷贝进 c                                         |
| c.emplace(inits)                | 使用inits 构造 c 中的一个元素                                    |
| c.erase(args)                   | 删除 args 指定的元素                                             |
| c.clear()                       | 删除 c 中的所有元素，返回 void                                   |

#### 迭代器

一个 **迭代器范围**（iterator range）由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者时尾元素之后的位置（one past the element）。这种元素范围为 **左闭合区间**
> [begin, end)

#### 容器定义和初始化

只有顺序容器的构造函数才能接受大小参数

|             |                                                                                         |
| ----------- | --------------------------------------------------------------------------------------- |
| C seq(n)    | seq  包含 n 个元素，这些元素进行了值初始化；此构造函数是 `explicit` 的（string 不适用） |
| C seq(n, t) | seq 包含 n 个初始化为值 t 的元素                                                        |

**标准库 array 具有固定大小**

与内置数组一样，标准库 array 的大小也是类型的一部分。当定义一个 array 时，除了指定元素类型，还要指定容器大小

```C++
array<int, 42>
array<string, 10>
```

由于大小是 array 类型的一部分，array 不支持普通的容器构造函数

### 顺序容器操作

除 array 外，所有标准容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小

|                       |                                                                                                                                                     |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| c.push_back(t)        | 在 c 的尾部创建一个值为 t 或由 args 创建的元素。返回 void                                                                                           |
| c.emplace_back(args)  |                                                                                                                                                     |
| c.push_front(t)       | 在 c 的头部创建一个值为 t 或由 args 创建的元素。返回 void                                                                                           |
| c.emplace_front(args) |                                                                                                                                                     |
| c.insert(p, t)        | 在迭代器 p 指向的元素之前创建一个值为 t 或由 args 创建的元素。返回指向新添加的元素的迭代器                                                          |
| c.emplace(p, args)    |                                                                                                                                                     |
| c.insert(p, n, t)     | 在迭代器 p 指向的元素之前插入 n 个值为 t 或由 args 创建的元素。返回指向新添加的第一个元素的迭代器；若 n 为 0，则返回 p                              |
| c.insert(p, b, e)     | 将迭代器 b 和 e 指定范围内的元素插入到迭代器 p 指向的元素之前。b 和 e 不能指向 c 中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回 p |
| c.insert(p, il)       | il 是一个花括号包围的元素值列表。将这些给定值插入到迭代器 p 指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回 p                |

forward_list 有自己专有版本的 insert 和 emplace
forward_list 不支持 push_back 和 emplace_back
vector 和 string 不支持 push_front 和 emplace_front

注：向一个 vector、string或 deque 插入元素会使所有指向容器的迭代器、引用和指针失效

**在容器中的特定位置添加元素**

每一个 `insert` 函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器的什么位置放置新元素
除了第一个迭代器参数之外，insert 函数还可以接受更多的参数，这与容器构造函数类似
通过使用 insert 的返回值，可以在容器中一个特定位置反复插入原始

**使用 emplace 操作**

C++ 11 引入了三个新成员：emplace_front、emplace 和 emplace_back，这些操作构造而不是拷贝元素
当调用 push 或 insert 成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个 emplace 成员函数时，则是将参数传递给元素类型的构造函数。emplace 成员使用这些参数在容器管理的内存空间中直接构造元素

```C++
vector<Sales_data> c;
c.emplace_back("test", 234, 423.534);
c.push_back("fesf", 432, 435.22);           // 错误：没有接受三个参数的 push_back 版本
c.push_back(Sales_data("fsr", 432, 435.21));// 正确：创建一个临时的 Sales_data 对象传递给 push_back
```

其中对 emplace_back 的调用和第二个 push_back 调用都会创建新的 Sales_data 对象。在调用 emplace_back 时，会在容器管理的内存空间中直接创建对象。而调用 push_back 则会创建一个局部临时对象，并将其压入容器中

emplace 函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配

#### 访问元素

#### 删除元素

|               |                                                                                                                                                      |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| c.pop_back()  | 删除 c 中尾元素。若 c 为空，则函数行为未定义。函数返回 void                                                                                          |
| c.pop_front() | 删除 c 中头元素。若 c 为空，则函数行为未定义。函数返回 void                                                                                          |
| c.erase(p)    | 删除迭代器 p 所指定的元素，返回一个指向被删除元素之后的迭代器，若 p 指向尾元素，则返回尾后（off-the-end）迭代器。若 p 是尾后迭代器，则函数行为未定义 |
| c.erase(b, e) | 删除迭代器 b 和 e 所指定范围内的元素。返回一个指向最后一个被删除元素之后的元素，若 e 本身就是尾后迭代器，则函数也返回尾后迭代器                      |
| c.clear()     | 删除 c 中的所有元素。返回 void                                                                                                                       |

forward_list 有特殊版本的 erase，并且不支持 pop_back
vector 和 string 不支持 pop_front
删除 deque 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效
指向 vector 或 string 中删除点之后位置的迭代器、引用和指针都会失效

#### 容器操作可能使迭代器失效

在向容器添加元素后：

- 如果容器是 vector 或 string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但之后的将会失效
- 对于 deque，插入到除首尾之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
- 对于 list 和 forward_list，指向容器的迭代器、指针和引用仍有效

当从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，此外：

- 对于 list 和 forward_list，指向容器其他位置的迭代器、引用和指针仍有效
- 对于 deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除 deque 的尾元素，则尾后迭代器会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响
- 对于 vector 和 string，指向被删除元素之前元素的迭代器、引用和指针仍有效

使用失效的迭代器、指针或引用是严重的运行时错误
当使用迭代器时，最小化要求迭代器必须保持有效的程序片段
由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器

### vector 对象是如何增长的

### 额外的 string 操作

#### 构造 string 的其他方法

|                          |                                                                                                                                                              |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| string s(cp, n)          | s 是cp指向的数组中前 n 个字符的拷贝                                                                                                                          |
| string s(s2, pos2)       | s 是 string s2 从下标 pos2 开始的字符的拷贝。若pos2>s2.size()，构造函数的行为未定义                                                                          |
| string s(s2, pos2, len2) | s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝。若 pos2 > s2.size()，构造函数的行为未定义。不管 len2 的值是多少，构造函数至多拷贝 s2.size() - pos2 个字符 |

**substr 操作**

`substr` 操作返回一个 string，它是原始 string 的一部分或全部的拷贝。可以传递给 substr 一个可选的开始位置和计数值：

```C++
string s("hello world");
string s2 = s.substr(0, 5);     // hello
string s3 = s.substr(6);        // world
string s4 = s.substr(6, 11);    // world
string s5 = s.substr(12);       // 抛出一个 out_of_range 异常
```

#### string 搜索操作

string 类提供了 6 个不同的搜索函数，每个函数都有 4 个重载版本。每个搜索操作都返回一个 `string::size_type` 值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为 `string::npos` 的static 成员。
标准库将 npos 定义为一个 `const string::size_type` 类型，并初始化为值 -1。由于 npos 是一个 `unsigned` 类型，此初始值意味着 npos 等于任何 string 最大的可能大小。

`find` 函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个匹配位置的下标，否则返回 npos：

```C++
string name("AnnaBelle");
auto pos1 = name.find("Anna");  // pos1 = 0
```

搜索（以及其他 string 操作）是大小写敏感的

一个更复杂的问题是查找与给定字符中任何一个字符匹配的位置。例如定位 name 中的第一个数字：

```C++
string numbers("0123456789");
string name("r2d2");
auto pos = name.find_first_of(numbers); // 返回1，即 name 中第一个数字的下标
```

如果要搜索第一个不在参数中的字符，应该调用 `find_first_not_of`。例如搜索 dept 中第一个非数字字符：

```C++
string dept("03714p3");
auto pos = dept.find_first_not_of(numbers); // 返回5——字符'p'的下标
```

#### 数值转换

C++ 11 引入了多个函数，可以实现数值数据与标准库 string 之间的转换：

```C++
int i = 42;
string s = to_string(i);
double d = stod(s);
```

| | |
|-|-|
|to_string(val) | 一组重载函数，返回数值 val 的 string 表示。val 可以是任何算术类型 |
| stoi(s, p, b) | 返回 s 的起始字串（表示整数内容）的数值，返回值类型分别是 int |
| stol(s, p, b) | long |
| stoul(s, p, b) | unsigned long |
| stoll(s, p, b) | long long |
| stoull(s, p, b) | unsigned long long，b表示转换所用的基数，默认为 10。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，p 默认为 0，即函数不保存下标 |

要转换为数值的 string 中第一个非空白必须是数值中可能出现的字符：

```C++
string s2 = "pi = 3.14";
double d = stod(s2.substr(s2.find_first_of("+-.0123456789")));
```

首先调用 `find_first_of` 来获得 s 中第一个可能是数值的一部分的字符的位置，然后将 s 中此位置开始的字串传递给 stod
stod 函数读取此参数，处理其中的字符，直到遇到不可能是数值的一部分的字符，然后将这个数值的字符串表示形式转换为对应的浮点数

string 参数中第一个非空白符必须是符号（+ 或 -）或数字。它可以是 0x 或 0X 开头来表示十六进制数
对那些将字符串转换为浮点值的函数，string 参数也可以以小数点（.）开头，并可以包含 e 或 E 来表示指数部分。
对那些将字符串转换为整型值的函数，根据基数不同，string 参数可以包含字母符号，对应于大于数字9的数

### 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：`stack`、`queue`、`priority_queue`
**适配器**（adaptor）是标准库中的一个通用概念

## Generic Algorithms 泛型算法

标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数独立于任何特定的容器。这些算法是通用的（generic，或称泛型的）：它们可用于不同类型的容器和不同类型的元素

大多数算法都定义在头文件 `algorithm` 中。标准库还在头文件 `numeric` 中定义了一组数值泛型算法

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作

**迭代器令算法不依赖于容器，...**

利用迭代器解引用运算符可以实现元素访问；如果发现匹配的元素，`find`可以返回指向该元素的迭代器；用迭代器递增运算发可以移动到下一个元素；尾后迭代器可以用来判断是否到达给定序列的末尾；`find`可以通过返回尾后迭代器来表示为找到给定元素

**...，但算法依赖于元素类型的操作**

虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作。例如`find`用元素类型的 `==` 运算符完成每个元素于给定值的比较。其他算法可能要求元素类型支持 `<` 运算符。不过大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符

**算法永远不会执行容器的操作**
泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。这个特性带来了一个编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素

标准库定义了一类特殊的迭代器，称为插入器（inserter）。与普通迭代器只能遍历所绑定的容器相比，当给插入器赋值时，它们会在底层的容器上执行插入操作。因此，当一个算法操作一个这样的迭代器时，迭代器可以完成向容器添加元素的效果，但算法本身永远不会做这样的操作

### 初识泛型算法

虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序

#### 只读算法

一些算法只会读取其输入范围内的元素，而从不改变元素。`find` 和 `count` 就是如此
另一个只读算法是 `accumulate`，它定义在头文件 `numeric` 中。`accumulate` 函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值

```C++
vector<int> vec = {1, 2, 3, 4, 5};
int sum = accumulate(vec.begin(), vec.end(), 0); // 对vec中的元素求和，和的初值是0
```

`accumulate` 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型

**算法和元素类型**

`accumulate` 将第三个参数作为求和起点蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可执行的。
即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。上例中，vec中的元素可以是 int，或者是 double、long long 或任何其他可以加到 int 上的类型

由于 string 定义了 `+` 运算符，所以我们可以通过调用 `accumulate` 来将 vector 中所有 string 元素连接起来

```C++
string sum = accumulate(v.cbegin(), v.cend(), string(""));
```

注意，我们通过第三个参数显式地创建了一个 string。将空串当作一个字符串字面量传递给第三个参数是不可以的，会导致一个编译错误

```C++
// 错误：const char* 上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```

原因在于，如果我们传递了一个字符串字面量，用于保存和对象的类型将是 `const char*`。由于 `const char*` 并没有`+`运算符，此调用将产生编译错误

Note：对于只读取而不改变元素的算法，通常最好使用 `cbegin()` 和 `cend()`

**操作两个序列的算法**

`equal` 用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回 `true`，否则返回 `false`
此算法接受三个迭代器：前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素：

```C++
// roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), reoster2.cbegin());
```

由于 `equal` 利用迭代器完成操作，因此我们可以通过调用 `equal` 来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要能用`==`来比较两个元素类型即可
例如，在此例中，roster1 可以是 `vector<string>`，而 roster2 是 `list<const char*>`

但是，`equal` 基于一个非常重要的假设：第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素

#### 写容器元素的算法

一些算法将新值赋予序列中的元素。使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目
一些算法会自己向输入范围写入元素。这些算法本质上并不危险，它们最多写入与给定序列一样多的元素

算法 `fill` 接受一堆迭代器表示一个范围，还接受一个值作为第三个参数。`fill` 将给定的这个值赋予输入序列中的每个元素

```C++
fill(vec.begin(), vec.end(), 0); // 将每个元素重置为 0
// 将容器的一个子序列设置为 10
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
```

由于 `fill` 向给定输入序列中写入数据，因此，只要我们传递了一个有效的输入序列，写入操作就是安全的

**算法不检查写操作**

一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始
例如，函数 `fill_n` 接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素

```C++
vector<int> vec; // 空 vector
// 使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0); // 将所有元素重置为 0
```

函数 `fill_n` 假定写入指定个元素是安全的。即，如下形式的调用

> fill_n(dest, n, val)

`fill_n` 假定 dest 指向一个元素，而从 dest 开始的序列至少包含 n 个元素

不能在空容器上调用 `fill_n`或类似的写元素的算法

**介绍 back_inserter**

## Associative Containers 关联容器

关联容器支持高效的关键字查找和访问。两个主要的**关联容器**类型是 **map** 和 **set**。
map 中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示于索引相关联的数据
set 中每个元素只包含一个关键字；set 支持高效的关键字查询——检查一个给定的关键字是否在 set 中

### 概述

#### 关键字类型的要求

**使用关键字类型的比较函数**

用来组织一个容器中元素的操作的类型也是该容器的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型

定义比较函数

```C++
bool compareIsbn(const Sales_data &lhs, const Sales_data & rhs) {
    return lhs.isbn() < rhs.isbn();
}

multiset<Sales_data, delctype(compareIsbn)*> bookstore(compareIsbn);
```

为了使用自己定义的操作，在定义 `multiset` 时必须提供两个类型：关键字类型 Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向 compareIsbn。

#### pair 类型

`pair` 标准库类型定义在头文件 `utility` 中，一个 `pair` 保存两个数据成员。类似容器，`pair`是一个用来生成特定类型的模板。当创建一个`pair`时，必须提供两个类型名，`pair`的数据成员将具有对应的类型。两个类型不要求一样：

```C++
pair<string, string> anon;
pair<string, size_t> word_count;
pair<string, vector<int>> line;
```

`pair`的默认构造函数对数据成员进行值初始化。与其他标准库类型不同，`pair`的数据成员是`public`的。两个成员分别命名为`first`和`second`。用普通的成员访问符号来访问它们

**创建pair对象的函数**

用`make_pair`来生成`pair`对象，

### 关联容器操作

#### 关联容器迭代器

**遍历关联容器**

```C++
auto map_it = word_count.begin();
while (map_it != word_count.end()) {
    ....
    ++map_it;
}
```

#### 添加元素

**向 map 添加元素**

对一个 map 进行 insert 操作时，必须记住元素类型是 pair

```C++
// 向 word_count 插入 word 的 4 种方法
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
```

**检测 insert 的返回值**

insert（或 emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的 insert 和 emplace 版本返回一个 pair，pair的first 成员是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出元素是插入成功（true）还是已经存在于容器中（false）。

## Dynamic Memory

我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部`static`对象、类`static`数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非`static`对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；`static`对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作**自由空间**（free store）或**堆**（heap）。程序用堆来存储**动态分配**（dynamically allocate）的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们

### 动态内存与智能指针

在C++中，动态内存的管理是通过一对运算符来完成的：**new**，在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化；**delete**，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

为了更容易（也更安全）地使用动态内存，C++ 11 标准库提供了两种**智能指针**（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。这两种指针的区别在于管理底层指针的方式：**shared_ptr**允许多个指针指向同一个对象；**unique_ptr**则“独占”所指向的对象。标准库还定义了一个名为**weak_ptr**的伴随类，它是一种弱引用，指向 `shared_ptr` 所管理的对象。这三种类型都定义在 `memory` 头文件中

#### shared_ptr 类

类似 `vector`，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型：

```C++
shared_ptr<string> p1;      // p1 可以指向 string
shared_ptr<list<int>> p2;   // p2 可以指向 int 的 list
```

默认初始化的智能指针中保存着一个空指针。智能指针的使用方式与普通指针类似，解引用一个智能指针返回它指向的对象
如果在一个条件判断中使用智能指针，效果就是检测它是否为空：

```C++
// 如果 p1 不为空，检查它是否指向一个空 string
if (p1 && p1->empyt()) {
    *p1 = "hi"; // 如果 p1 指向一个空 string，解引用 p1，将一个新值赋予 p1
}
```

| shared_ptr 和 unique_ptr | 都支持的操作 |
|-|-|
| p | 将 p 作为一个条件判断，若 p 指向一个对象，则为 true |
| *p | 解引用 p，获得它指向的对象 |
| p->mem | 等价于 (*p).mem |
| p.get() | 返回 p 中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| swap(p, q) | 交换 p 和 q 中的指针 |
| p.swap(q) | |

| shared_ptr | 独有的操作 |
|-|-|
| make_shared<T>(args) | 返回一个`shared_ptr`，指向一个动态分配的类型为T的对象。使用*args*初始化此对象 |
| shared_ptr<T>p(q) | p 是 shared_ptr q 的拷贝；此操作会增加 q 中的计数器。q 中的指针必须能转换为 T* |
| p = q | p 和 q 都是 `shared_ptr`，所保存的指针必须能相互转换。此操作会递减 p 的引用计数，递增 q 的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放 |
| p.unique() | 若 p.use_count() 为 1，返回 true；否则返回 false |
| p.use_count() | 返回与 p 共享对象的智能指针数量；可能很慢，主要用于调试 |

**make_shared 函数**

最安全的分配和使用动态内存的方法是调用一个名为 `make_shared` 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr`。与智能指针一样，`make_shared` 也定义在头文件 `memory` 中

当使用  `make_shared` 时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：

```C++
// 指向一个值为 42 的 int 的 shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
// p4 指向一个值为 "9999999999" 的 string
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5 指向一个值初始化的 int，即，值为 0
shared_ptr<int> p5 = make_shared<int>();
```

类似顺序容器的 `emplace` 成员，`make_shared` 用其参数来构造给定类型的对象。如果不传递任何参数，对象就会进行值初始化

通常用 `auto` 定义一个对象来保存 `make_shared` 的结果，这种方式较为简单：

```C++
// p6 指向一个动态分配的空 vector<string>
auto p6 = make_shared<vector<string>>();
```

**shared_ptr 的拷贝和赋值**

当进行拷贝或赋值操作时，每个 `shared_ptr` 都会记录由多少个其他 `shared_ptr` 指向相同的对象：

```C++
auto p = make_shared<int>(42);  // p 指向的对象只有 p 一个引用者
auto q(p);  // p 和 q 指向相同对象，此对象有两个引用者
```

可以认为每个 `shared_ptr` 都有一个关联的计数器，通常称其为**引用计数**（reference count）。无论何时我们拷贝一个 `shared_ptr`，计数器都会递增。当我们给 `shared_ptr` 赋予一个新值或是 `shared_ptr` 被销毁时，计数器就会递减

一旦一个 `shared_ptr` 的计数器变为0，它就会自动释放自己所管理的对象：

```C++
auto r = make_shared<int>(42); // r 指向的 int 只有一个引用者
r = q;  // 给 r 赋值，令它指向另一个地址
        // 递增 q 指向的对象的引用计数
        // 递减 r 原来指向的对象的引用计数
        // r 原来指向的对象已没有引用者，会自动释放
```

到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针能记录有多少个 `shared_ptr` 指向相同的对象，并能在恰当的时候自动释放对象

**shared_ptr 自动销毁所管理的对象···**

当指向一个对象的最后一个 `shared_ptr` 被销毁时，`shared_ptr` 类会自动销毁此对象。它是通过**析构函数**（destructor）完成销毁工作的。`shared_ptr` 的析构函数会递减它所指向的对象的引用计数，如果引用计数变为 0，`shared_ptr` 的析构函数就会销毁对象，并释放它占用的内存

对于一块内存，`shared_ptr` 类保证只要有任何 `shared_ptr` 对象引用它，它就不会被释放掉

**使用了动态生存期的资源的类**
程序使用动态内存出于以下三种原因之一：

1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序要在多个对象之间共享数据

#### 直接管理内存

#### unique_ptr

### 内存模型

#### 背景

1. 编译器与处理器的优化：
  编译器在编译时为了提升代码执行效率，会对代码做乱序处理，而处理器也会对指令做乱序执行。这在单线程上没有问题，但多线程上问题很大。内存模型就是为了保证代码的各种一致性被提出来的
2. Cache Coherency
  现代CPU都是拥有多级Cache的，其中cache的访问权限有限，有些cache中的数据只能被一个核心看到，这在多线程访问数据时会出现问题

#### 内存模型

##### Sequential Consistency

顺序一致性，是一致性最严格的内存模型，它要求：

1. 每个处理器的执行顺序和代码一致
2. 处理器并行执行的结果和处理器按照某种顺序执行的结果一致

缺点是性能差，它在内存面前是在单核工作的

##### Total Store Ordering

全存储模型，是在顺序一致模型中，放松了对 cache 的要求，它认为一个写操作只要写到这个核心的 cache 中就可以直接返回了

#### Relaxed Memory Model

松弛内存模型，在全存储排序的基础上又放松了要求，允许编译器在不改变单核允许结果的情况下对代码重排

C++11 开始完善对内存模型的支持，目前共有6种内存模型相关的枚举值，但实际上是4种内存模型

- Sequential Consistency
  - memory_order_seq_cst：顺序一致性模型，是默认的选项，保证所有原子操作的顺序一致性
- Acquire-Release
  - memory_order_acquire：用来修饰一个读操作，表示在本线程中，所有后续的内存操作都必须在本条原子操作完成后执行
  - memory_order_release：用来修饰一个写操作，表示在本线程中，所有之前的内存操作完成后才能执行本条原子操作
  - memory_order_acq_rel：同时包含 memory_order_acquire 和 memory_order_release 标志
- Release-Consume：比 Acquire-Release 更宽松的模型，只对具有关联性的变量做顺序保证，而不保证前后无关的代码顺序
  - memory_order_consume
- Relaxed：松弛模型，不同线程的原子操作顺序任意，但单个变量的读写是原子操作
  - memory_order_relaxed

### 内存栅栏

memory barrier(fence)

由于有了 cache 的存在，很多操作不用写到内存就可以继续执行后面的操作，为了保证某些操作是写入到内存才执行的，就引入了内存栅栏
内存栅栏的作用是：所有在内存栅栏之前的内存操作，都要写入到内存中。内存栅栏其实是显式的在程序的一些执行点上保证顺序一致性

C++11 提供的接口：std::atomic_thread_fence

## 单例模式

C++ 的单例就是一个外表为类形式的命名空间

首先不能有 public 的构造函数，因为如果有的话，它就会允许在类外被实例化
提供一种静态访问该类的方法

```C++
class Singleton
{
public:
    Singleton(const Singleton&) = delete;   // delete 拷贝构造函数
    static Singleton& GetInstance() {
        if (s_Instance == nullptr) {
            s_Instance = Singleton();
        }
        return s_Instance;
    }

    void Function() {}
private:
    Singleton() {}

    static Singleton s_Instance;
}


int main()
{
    // 为了禁止拷贝构造一个单例，需要将该类的拷贝构造函数 delete
    Singleton instance = Singleton::GetInstance();

    Singleton::GetInstance().Function()
}
```

## 并发编程

C++11 中引入了几个头文件来支持多线程编程：

- <atomic>：主要声明了两个类，std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作函数
- <thread>：主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中
- <mutex>：主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard、std::unique_lock，以及其他的类型和函数
- <condition_variable>：主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any
- <future>：主要声明了 std::promise 和 std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，srd::asynic() 函数就声明在此头文件中

## 多线程同步

### 多线程的两个主要用途

1. 保护共享数据(Protecting shared data from concurrent access)
2. 同步并行操作(Synchronizing concurrent operations)

### 保护共享数据(Protecting shared data from concurrent access)

一般我们用互斥锁(mutual exclusion, mutex)来保护共享数据. 比如在一些场景下, 有一些线程往共享数据里写数据, 有一些线程从共享数据里读数据. 两个或多个线程读数据完全没问题, 但是我们要防止两个线程同时写数据, 也要防止一个线程在写的同时另一个线程还在读. 否则这样就会发生竞争条件(race condition, 官方翻译是"竞争条件", 但我觉得可以直译成"竞争情况"或者意译成"数据竞争").

### 同步并行操作(Synchronizing concurrent operations)

这篇文章我们主要关注同步并行操作. 同步并行的意思是有可能我们会同时运行不同的事件(event), 我们需要协调他们的发生顺序, 比如一个线程必须要等另一个线程完成它的工作才能进行这个线程本身的下一部分工作.

大部分这样类型的问题都可以总结成生产者和消费者模式(producer-consumer pattern): 消费者需要等待生产者生产数据, 并且等待某种条件成真. 生产者生产数据并且改变那种条件.

### 同步并行操作的三种方法

在同步并行操作, 也就是在生产者和消费者模式里, 让消费者等待生产者设定的某个条件, 可以用三种方法完成:

1. 周期性检查条件(最简单但是最差的实现方法)
2. 使用条件变量(condition variables)
3. 使用futures和promises(理解起来比较复杂, 但有些场景可以很方便)

#### 方法1: 周期性检查条件

这是一个最简单但是最不好的方法, 看看它的优缺点:

优点: 容易理解

缺点:

- 消耗大量资源周期性检查(CPU使用率可能会飙升到100%)
- 不必要地周期性唤醒线程
- 垃圾设计

我们从一个简单的生产者消费者案例说起. 假如一个场景我们有一个送快递的线程(生产者), 和一个签收的线程(消费者). 消费者等待生产者的那个"条件", 就是快递是否准备好被接收了.

代码框架可以这样:

```C++
struct Packet {
  int id;
};

std::mutex m;
std::queue<Packet> packet_queue;

//生产者 - 生成快递包裹
void parcel_delivery() {}

//消费者 - 签收包裹
void recipient() {}

int main() {
  // 启动生产者和消费者线程
}
```

最原始的用互斥锁(mutex)的代码实现怎么写:

```C++
#include <chrono>
#include <iostream>
#include <mutex>
#include <queue>
#include <ratio>
#include <thread>

struct Packet {
  int id;
};

std::mutex m;
std::queue<Packet> packet_queue;

//生产者 - 生成快递包裹
void parcel_delivery() {
  // 周期性地生产"包裹"
  int packet_id = 0;
  while (true) {
    // 等待一段时间再投送
    std::this_thread::sleep_for(std::chrono::seconds(1));

    Packet new_packet{packet_id};
    {
      //使用lock_guard锁住这段括号{}以内的共享数据, 走出{}段落后会自动解锁
      //为什么用lock_guard? 这段代码即使出错, throw了, 这个段落结束后也会解锁,
      //从而避免死锁(Dead lock)
      std::lock_guard<std::mutex> l{m};
      std::cout << "Work is done and packet id [" << packet_id << "] is ready"
                << std::endl;
      packet_queue.push(new_packet);
    }
    packet_id++;
  }
}

//消费者 - 签收包裹
void recipient() {
  while (true) {
    {
      //使用lock_guard锁住这段括号{}以内的共享数据, 走出{}段落后会自动解锁
      std::lock_guard<std::mutex> l{m};

      //当共享数据queue里的包裹准备了, 就可以取出包裹了
      if (!packet_queue.empty()) {
        auto new_packet = packet_queue.front();
        packet_queue.pop();
        std::cout << "Received new packet with id: [" << new_packet.id << "]. ["
                  << packet_queue.size() << "] packets remaining" << std::endl;
      }
    }
    //这里消费者就疯狂周期性地加锁并且访问数据, 会导致CPU使用率飙升
    //为了避免这种情况, 每次结束后稍微休息一会, 但这方式治标不治本
    //还是没法避免周期性地唤醒这个线程
    //最倒霉情况还会完整睡上100ms才能拿到数据
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }
}

int main(int argc, const char** argv) {
  // 启动生产者和消费者线程
  std::thread producing_thread(parcel_delivery);
  std::thread consuming_thread(recipient);
  producing_thread.join();
  consuming_thread.join();
  return 0;
}
```

方法2: 使用条件变量(conditional variable)
看看条件变量的优缺点:

优点:

不浪费CPU资源
条件变量可以多次使用 (和后面要说的futures的一次使用对比)
缺点:

需要考虑无效唤醒(spurious wakeups)
需要考虑丢失唤醒(lost wakeups)
典型使用场景:

网络检测线程: 周期性检查数据, 通知工作线程

文件检查线程: 周期性检查文件, 通知工作线程

总结一下就是需要做通知的时候用. 所以我们的快递包裹和签收也符合这种使用场景, 我们需要快递线程通知签收线程.

```C++
#include <chrono>
#include <condition_variable>
#include <iostream>
#include <mutex>
#include <queue>
#include <thread>

struct Packet {
  int id;
};

std::condition_variable cond_var;
std::mutex m;

std::queue<Packet> packet_queue;

//生产者 - 生成快递包裹
void parcel_delivery() {
  // 周期性地生产"包裹"
  int packet_id = 0;
  while (true) {
    // 等待一段时间再投送
    std::this_thread::sleep_for(std::chrono::seconds(1));
    Packet new_packet{packet_id};
    {
      //使用lock_guard锁住这段括号{}以内的共享数据, 走出{}段落后会自动解锁
      //为什么用lock_guard? 这段代码即使出错, throw了, 这个段落结束后也会解锁,
      //从而避免死锁(Dead lock)
      std::lock_guard<std::mutex> l{m};
      std::cout << "Work is done and packet id [" << packet_id << "] is ready"
                << std::endl;
      packet_queue.push(new_packet);
    }
    packet_id++;
    cond_var.notify_one();
  }
}

//消费者 - 签收包裹
void recipient() {
  while (true) {
    //这里注意我们用了unique_lock, 下面会详细讨论一下
    std::unique_lock<std::mutex> lock{m};

    //这里的lambda函数必须是一个predicate, 也就是必须要返回true/false的函数
    cond_var.wait(lock, []() { return !packet_queue.empty(); });

    auto new_packet = packet_queue.front();
    packet_queue.pop();
    std::cout << "Received new packet with id: [" << new_packet.id << "]. ["
              << packet_queue.size() << "] packets remaining" << std::endl;
  }
}

int main(int argc, const char** argv) {
  // 1: Start two threads: Producer and consumer
  std::thread producing_thread(parcel_delivery);
  std::thread consuming_thread(recipient);
  producing_thread.join();
  consuming_thread.join();
  return 0;
}
```

把mutex传递给conditional variable这个过程中发生了什么?

```C++
{
    //锁上mutex
    std::unique_lock<std::mutex> lock{m};

    //这里在等待(wait)的时候, 其实是会解锁mutex, 并且等待条件满足后再重新锁上mutex
    //这样就保证了这个线程不会空转或者等待, 从而不消耗cpu资源
    cond_var.wait(lock, some_predicate_function);

    //操作一些被mutex保护的共享数据

    //手动解锁mutex, 如果不管, 在{}结束的时候也会解锁
    lock.unlock();
}
```

conditional variable在wait的时候, 底层发生了什么?

实际上调用wait之后, 里面操作系统层面线程库(operating system threading lib)里的操作是这样的:

1. 解锁mutex
2. 把当前线程放到一个等待队列(queue of wait threads)
3. 当收到通知notify_one的时候, 等待队列就会把一个线程释放出来
4. 当收到通知notify_all的时候, 等待队列就会把所有线程释放出来
5. 重新锁上mutex
6. 所以这样这个线程才没有占用CPU空转消耗资源.

C语言这部分可以怎么写:

```C
 pthread_mutex_lock(&lock);
    //如果条件不满足, 开始等待
    while (!some_predicate_function)
    {
        pthread_cond_wait(&cond_var, &lock);
        //如果被唤醒, 重新上锁后, 就会运行到这里
        //再次检查while的条件:
        //如果条件不满足, 继续新一轮等待, 锁又会被释放
        //如果条件满足, 才跳过while循环直接进行后续数据操作
    }
    //操作一些被mutex保护的共享数据...
    pthread_mutex_unlock(&lock);
```

##### 无效唤醒(spurious wakeups)

这个词spurious wakeups没有中文翻译但我觉得可以叫无效唤醒, 就是线程被唤醒之后又发现条件不满足, 再次回到等待状态

典型情况就会发生在上面提到的notify_all中:

我们也都能理解如果只需要通知一个线程的时候, 要调用notify_one而不是notify_all. 但看看用notify_all之后会发生什么:

1. 把所有等待队列里的线程都释放出来
2. 其中一个运气好的线程会拿到锁并且锁上, 检查条件后处理数据
3. (无效步骤)其他剩下的线程虽然被唤醒了, 但是都在等待解锁并进行下面的步骤
4. (无效步骤)等第2步中的线程完成工作解锁后, 第3步的其中一个线程拿到锁
5. (无效步骤)但数据可能已经被第2步的线程处理完了, 这个线程重新检查的条件不满足, 又被加进等待队列(wait queue)
6. (无效步骤)其他所有线程重复第3到第5步的操作

看看那些无效步骤, 结论就是不要闲着没事notify_all

##### 丢失唤醒(Lost Wakeups)

还有一点需要注意的是我们可能会丢失一些唤醒信号. 比如我们的生产者消费者模型里:

> 生产者线程: cond_var.notify_one();
> 消费者线程: cond_var.wait(lock, []() { return !packet_queue.empty(); });

生产者和消费者是在两个线程运行的, 所以我们没法确定他们俩的代码的运行顺序. 有可能生产者运行得比较快先调用了notify_one, 但是消费者还没运行到等待这一步. 这一个notify的通知就丢失了. 等到下一个notify的通知它才能继续运行, 或者也有可能永远等不到下一个通知永远结束不了了.

如果像我们之前C语言里的代码, 没有考虑好的话把while写成了if, 丢失唤醒(Lost Wakeups)就有可能发生:

```C
pthread_mutex_lock(&lock);
    //这里while改成了if, 可以复现Lost Wakeups
    if (!some_predicate_function)
    {
        //如果运行到这之前notify提前执行了, 这里是不是就永远得不到通知了?
        pthread_cond_wait(&cond_var, &lock);
    }
    pthread_mutex_unlock(&lock);
```

好在现在C++封装了这部分逻辑不容易写错了:

```C++
{
    std::unique_lock<std::mutex> lock{m};
    //不需要写while再检查条件了
    cond_var.wait(lock, some_predicate_function);
}
```

所以关键点还在于这个predicate检查判断条件, 必须要写好. 我们也可以不把这个判断条件传给wait, 比如就这么写cond_var.wait(lock);也能编译运行, 但显然很容易出现上述问题.

#### 方法3: 使用Future或Promise

除了直接使用线程, 我们还可以用高级一点的Future或者Promise. 没有相关背景知识的话可能还是需要费点力来理解这块. 我们先略扫一下他们的优缺点, 然后一会直接从案例里理解他们.

优点:

1. 不需要直接使用线程(std::thread)
2. 方便拿到线程运算结果
3. 没有无效唤醒(spurious wakeups)和丢失唤醒(lost wakeups)的问题
缺点:

每次只能生成一个事件(one-shot events), 不能像以前线程里那样一个线程不断生成数据或者消费数据

常见使用场景原文没说, 我觉得是在对未知的事件做异步计算的场景可能更有用, 比如处理前端用户不同的请求, 或者分布式计算接收不同的计算请求.

##### Future

首先我们来看看`std::future`. `std::future`本身是一个容器, 它包含了一种可交给未来计算的内容, 这个内容的计算因为会费时间我们延后运行. 我们可以让`std::future`返回一个值, 比如返回`int`, 可以这么写`std::future<int>`. 也可以让`std::future`单纯做计算不返回任何东西, 就可以这样`std::future<void>`.

刚才提过, future和之前两种方法(用mutex或conditional variable)的不同点就是它是一次性的, 每一个future都表示它能做一次计算. 但是好处是我们不需要手动管理线程了, 甚至在我们的代码里都见不到thread这个东西, future自动把计算请求放到额外的一个线程中计算并且等待结果. 这样代码就更容易理解也更好维护了.

因为future的局限性, 光用future本身没法完全复现我们之前准备和接收包裹那样的生产者消费者模型案例. 我们来看看下面的代码案例.

先来一个最简单的例子, 看看怎么用`std::async`得到一个`std::future`并且得到计算结果的:

```C++
#include <chrono>
#include <future>
#include <iostream>
#include <vector>

struct Packet {
    int id;
};

Packet parcel_delivery() {
    static int packet_id = 0;
    Packet packet {
        packet_id
    };
    packet_id++;
    std::this_thread::sleep_for(std::chrono::seconds(3));
    return packet;
}

int main(int argc, const char ** argv) {

    std::future<Packet> future = std::async(std::launch::async, parcel_delivery);

    std::cout << "Wait for delivery" << std::endl;

    auto new_packet = future.get();
    std::cout << "Received new packet with id: " << new_packet.id << std::endl;

    return 0;
}
```

再改成一个创建多个std::future的例子, 也就是隐式创建了多个线程, 看看他们是怎么并行的：

```C++
#include <chrono>
#include <future>
#include <iostream>
#include <vector>


struct Packet {
    int id;
};

Packet parcel_delivery() {
    static int packet_id = 0;
    Packet packet {
        packet_id
    };
    packet_id++;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return packet;
}

int main(int argc,
    const char ** argv) {

    std::vector < std::future < Packet >> list_of_futures;
    for (int i = 0; i < 10; ++i) {
        list_of_futures.emplace_back(std::async(std::launch::async, parcel_delivery));
    }

    std::cout << "Wait for delivery" << std::endl;

    for (auto & future: list_of_futures) {
        auto new_packet = future.get();
        std::cout << "Received new packet with id: " << new_packet.id << std::endl;
    }
    return 0;
}
```

我们可以看到, 用std::async生成了std::future, 之后拿到结果, 完全避免了手动使用mutex和thread.

最后一个问题, 调用std::async和普通的多线程的区别在哪? 每次我们调用std::async, 就会额外生成一个线程吗?

答案是:

如果我们用了std::launch::asyncflag, 比如std::async(std::launch::async, parcel_delivery), 就会额外生成一个线程.

如果我们用了std::launch::deferredflag (推迟的意思), 比如std::async(std::launch::deferred, parcel_delivery), 就不会额外生成一个线程, 只是单纯推迟运算而已.

如果我们什么都不写, 比如std::async(parcel_delivery), 按C++标准, 默认可以用任意一种方式, 但是实际上主流编译器的默认方法都是用std::launch::async, 也就是会额外生成一个线程.

##### Promise

如前面所说, 使用std::async(和std::launch::asyncflag), 每生成一个future就会额外生成一个线程. 所以简化的future的使用场景还是挺有限的. 如果我们就想要一个线程来运行多个future, 我们可能就要考虑结合promise和future了.

std::promise和std::future刚好相反.

使用std::future的时候, 我们把计算函数传给std::async创建出一个std::future(和一个隐藏的线程).

使用std::promise的时候, 我们先创建一个std::promise, 通过std::promise获取一个std::future, 同时声明std::promise用来装载计算函数的结果, 最后把它和计算函数一起放进一个显式的线程做计算.

另一种理解方式是, 我们可以把std::async理解成一个函数, 它能创建一个promise, 把promise放进一个线程, 最后返回这个promise对应的future.

说起来特别绕, 还是直接看下面的最简单的代码案例吧:

```C++
#include <chrono>
#include <future>
#include <iostream>
#include <thread>
#include <vector>
struct Packet {
  int id;
};

void parcel_delivery(std::promise<Packet> &&promise) {
  static int id = 0;
  Packet packet{id};
  id++;

  std::this_thread::sleep_for(std::chrono::seconds(1));
  std::cout << "preparing packet with id: " << packet.id << std::endl;

  std::this_thread::sleep_for(std::chrono::seconds(2));
  std::cout << "ready to deliver packet with id: " << packet.id << std::endl;

  promise.set_value(packet);
}

int main(int argc, const char **argv) {

  std::promise<Packet> packet_promise;
  std::future<Packet> future = packet_promise.get_future();
  std::thread delivery_thread(parcel_delivery, std::move(packet_promise));

  std::cout << "Wait for delivery" << std::endl;

  auto new_packet = future.get();
  std::cout << "Received new packet with id: " << new_packet.id << std::endl;

  delivery_thread.join();

  return 0;
}

/*
输出
Wait for delivery
preparing packet with id: 0
ready to deliver packet with id: 0
Received new packet with id: 0
*/
```
