# The C Programming Language

## A Tutorial Introduction

### Getting Started

一个 C 语言程序，无论其大小如何，都是由*函数*和*变量*组成的
函数中包含一些*语句（statements）*，以指定要执行的计算操作；变量则用于存储计算过程中使用的值
main 是一个特殊的函数名——每一个程序都从 main 函数的起点开始执行
函数之间进行数据交换的一种方式是调用函数向被调用函数提供一个值（参数）列表

### Symbolic Constants(符号常量)

#define 指令可以把符号名（或称为符号常量）定义为一个特定的字符串：

#define 名字 替换文本

该定义之后，程序中出现的所有在 #define 中定义的名字都将用相应的替换文本替换
名字与普通变量名的形式相同：都是以字母打头的字母和数字序列；替换文本可以是任何字符序列

#define PI 3.14

符号常量名通常用大写字母拼写，以作区分
注意，#define 指令行的末尾没有分号

### Character Input and Output

标准库提供的输入/输出模型非常简单。无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理
文本流（text stream）是多行字符构成的字符序列，每行字符由0个或多个字符组成，行末是一个换行符
标准库负责使每个输入/输出流都遵守这一模型

标准库提供了一次读/写一个字符的函数，最简单的是 getchar 和 putchar 两个函数
每次调用时，getchar 函数从文本流中读取下一个输入字符，并将其作为结果值返回

c = getchar()

每次调用 putchar 函数时将打印一个字符

putchar(c)

### Arguments-Call by Value

在 C 语言中，所有函数参数都是通过“值”传递的。传递给被调用函数的参数值存放在临时变量中，而不是原来的变量
被调用函数不能直接写该主调用函数中变量的值
当要让函数能够修改主调函数中的变量，调用者需要向被调用函数提供变量的地址（变量的指针），被调用函数需要将对应的参数声明为指针类型，并通过它间接访问变量
当把数组名用作参数时，传递给函数的值时数组起始元素的位置或地址——它并不复制数组元素本身
被调用函数可以通过数组下标访问和修改数组元素的值

### External Variables and Scope (外部变量与作用域)

在函数中声明的变量是该函数的私有变量或局部变量，其他函数不能直接访问它们
函数中的所有局部变量只在函数被调用时存在，在函数执行完退出时消失，其他语言通常将这类变量称为自动变量（automatic）
由于自动变量只在函数调用执行期间存在，因此，在函数的两次调用之间，自动变量不保存前次调用时的赋值，且在每次进入函数时都要显式为其赋值

处自动变量外，还可以定义位于所有函数外部（external）的变量，所有函数中都可以通过变量名访问这种变量
由于外部变量可以在全局范围内访问，因此，函数间可以通过外部变量交换数据，而不必使用参数表
外部变量在程序执行期间一直存在，而不是在函数调用时产生、在函数执行完毕时消失。
外部变量必须定义在所有函数之外，且只能定义一次，定义后编译器将为它分配存储单元
在每个需要访问外部变量的函数中必须通过 extern 关键字显式声明其为外部变量，可也以通过上下文隐式声明
某些情况下可以省略 extern 声明。在源文件中，如果外部变量的定义出现在使用它的函数之前，可以省略 extern 声明
当如果在多个文件中使用全局变量，必须使用 extern 显式声明来建立变量与其定义之间的联系
通常将变量和函数的 extern 声明放在一个单独的头文件中

定义（define）表示创建变量或分配存储单元，而声明（declaration）指的是说明变量的性质，但并不分配存储单元

## Type, Operators and Expressions

### Data Types and Sizes

There are only a few basic data types in C:

- char: a single byte, capable of holding one character in the local character set
- int: an integer, typicall reflecting the natural size of integers on the host machine
- float: single-precision floating point
- double: double-precision floating point

此外，还可以在这些基本数据类型前面加上限定符。short 和 long 两个限定符用于限定整型：

short int sh;
long int counter;

上述声明中，int 关键字可以省略

### Constants (常量)

类似于 1234 的整数常量属于 int 类型，long 类型的常量以字母 l 或 L 结尾，例如 12345L，如果一个整数超过 int 类型范围，也会被当作 long 类型处理。无符号常量以字母 u 或 U 结尾，后缀 ul 或 UL 表示 unsigned long
16 进制的前缀为 0x，8 进制的前缀为 0，二者同样可以使用后缀 L 和 U 表示 long 类型和 unsigned 类型

一个字符常量是一个整数，用单引号括起来，如 'x'
某些字符可以通过转移字符序列（例如，换行符\n）表示字符和字符串常量

C 语言中的全部转义字符：

|   |   |
|---|---|
| \a | 响铃符 |
| \b | 回退符 |
| \f | 换页符 |
| \n | 换行符 |
| \r | 回车符 |
| \t | 横向制表符 |
| \v | 纵向制表符 |
| \\ | 反斜杠 |
| \? | 问号 |
| \' | 单引号 |
| \" | 双引号 |
| \ooo | 八进制 |
| \xhh | 十六进制 |

字符常量 '\0' 表示值为 0 的字符，也就是空字符（null）

只包含常量的表达式是常量表达式，它只在编译时求值，而不在运行时求值

字符串常量也叫字符串字面量，是用双引号括起来的多个字符组成的字符序列："Hello"
编译时可以将多个字符串常量连接起来，例如：
"Hello," " world"
等价于
"Hello, world"

技术上，字符串常量就是字符数组。字符串的内部表示用一个空字符 '\0' 作为结尾，因此存储字符串的实际字符数比双引号内的字符数多一个
C 语言对字符串的长度没有限制，但是 C 语言并不维护字符串长度，程序必须扫描整个字符串才能确定其长度
标准库函数 strlen(s) 可以返回字符串参数 s 的长度，但长度并不包括结尾的 '\0'
标准头文件 <string.h> 中声明了 strlen 和其他字符串函数

枚举常量是另一种常量，枚举是一个常量常量整形值的列表，例如：
enum boolean { NO, YES };
在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，以此类推
如果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增

```C
enum mouths { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
                    /* FEB = 2, MAR = 3, etc. */
```

不同枚举中的名字必须互不相同

枚举为建立常量值与名字之间的关联提供了一种便利的方式
编译器并不检查 enum 类型的变量中存储的值是否为该枚举的有效值

### Declarations

所有变量都必须先声明再使用，尽管某些变量可以通过上下文隐式地声明
一个声明指定一种变量类型，后面的变量表可以包括多个该类型的变量
可以在声明的同时对其进行初始化
如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式
每次进入函数或程序块是，显式初始化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式
默认情况下，外部变量与静态变量将被初始化为 0
未经显式初始化的自动变量的值为未定义值（即无效值）
任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对数组而言，const 限定符指定数组所有元素的值都不能被修改

```C
const double pi = 3.1415;
const char msg[] = "warning: ";
```

const 限定符也可以配合数组参数使用，表明函数不能修改数组元素的值

```C
int strlen(const char[]);
```

### Arithmetic Operators

### Relational and Logical Operators

### Type Conversions (类型转换)

当一个运算符的几个操作数类型不同时，需要通过一些规则把它们转换为某种共同的类型。一般来说，自动转换会把“较窄的”操作数转换为“较宽的”操作数，并且不丢失信息的转换
不允许使用无意义的表达式，例如将 float 类型作为数组下标
针对可能导致信息丢失的表达式，编译器可能会给出警告信息，比如把较长的整型值赋给较短的整型变量，等，但这些表达式并不非法

## Control Flow

## Function and Program Structure

### External Variables(外部变量)

外部变量定义在函数之外，因此可以在多个函数中使用。由于 C 语言不允许在一个函数中定义其他函数，因此函数本身是“外部的”。
默认情况下，通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中称这一性质为*外部链接*）
因为外部变量可以在全局范围内访问，这为函数间交换数据提供了一种代替函数参数与返回值的方式
外部变量比内部变量具有更大的作用域和更长的生存期，外部变量永久存在，它们的值在一次函数调用到下一次函数调用之间保持不变

### Scope Rules(作用域规则)

构成 C 语言程序的函数与外部变量可以分开编译，一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载
名字的作用域指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说，其作用域是声明该变量名的函数
不同函数中声明的具有相同名字的各个局部变量之间没有任何关系
外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束

### Header Files(头文件)

### Static Variables

用 static 限定词声明外部变量与函数，可以将其的作用域限定为被编译源文件的剩余部分
通过 static 限定外部对象可以达到隐藏外部对象的目的
static 也可用于声明内部变量。static 类型的内部变量不管其所在函数是否被调用，它一直存在。
换句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量

### Register Variables

register 声明告诉编译器其所声明的变量在程序中使用频率较高，应将其放在机器的寄存器中。但编译器可以忽略此选项

### Initialization(初始化)

在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值没有定义（即为无用信息）
对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（在程序开始执行前进行初始化）
对于自动变量与寄存器变量，则在每次进入函数或程序块时都将被初始化

### The C Preprocessor(C 预处理器)

预处理器是编译过程中单独执行的第一个步骤。有两个最常用的预处理指令：#include 指令（用于在编译期间把指定文件的内容复制到当前文件中）和#define 指令（用任意字符序列替代一个标记）

#### File Include(文件包含)

文件 include 使得处理大量的 #define 指令以及声明更加方便，在源文件中，任何形如：

```C
#include "filename"
#include <filename>
```

的行都将被替换为由文件名指定的文件的内容。如果文件名用引号引起来，则在源文件所在位置查找该文件；如果在该位置没有找到文件，或者如果文件名用尖括号括起来的，则将根据相应的规则查找该文件，这个规则同具体的实现有关
源文件开始处通常会有多个 #include 指令，用以包含常见的 #define 语句和 extern 声明，或从头文件中访问库函数的函数原型声明

#### Macro Substitution(宏替换)

宏定义的形式如下：

> #define 名字 替换文本

这是最简单的宏替换——后续所有出现*名字*记号的地方都将被替换为*替换文本*
#define 指令中的名字与变量的命名方式相同，替换文本可以是任意字符串
通常情况下 #define 指令占一行，替换文本是 #define 指令行尾部的所有剩余部分内容，也通过在行末尾加上反斜杠符 \ 将较长的宏定义分成多行
#define 指令定义的名字的作用域从其定义点开始，到被编译的源文件的末尾结束
替换只对记号进行，对括在引号中的字符串不起作用

#### Conditional Inclusion(条件包含)

还可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行的过程中进行计算的。这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段
#if 语句对其中的常量整型表达式（其中不能包含 sizeof、类型转换运算符或 enum 常量）进行求值，若该表达式的值不等于 0，则包含其后的各行，直到遇到 #endif、#elif 或 #else 语句
在 #if 语句中可以使用表达式 defined(名字)，该表达式遵循下列规则：当*名字*已经定义时，其值为 1，否则，其值为 0
例如，为保证 hdr.h 文件的内容只被包含一次：

```C
#if !defined(HDR)
#define HDR
#include "hdr.h"
#endif
```

第一次包含头文件 hdr.h 时，将定义名字 HDR，此后再次包含该头文件时，会发现该名字已经定义，这样将直接跳转到 #endif 处
类似的方式可以用来避免多次重复包含同一文件

## Pointers and Arrays

指针是一种保存变量地址的变量
通常的机器有一系列连续编号或编址的存储单元
指针是能够存放一个地址的一组存储单元（通常是2个或4个字节）
一元运算符 & 可用于取一个对象的地址

p = &c;

将 c 的地址赋值给变量 p，称 p 为“指向” c 的指针。
地址运算符 & 只能应用于内存中的对象，即变量与数组元素，不能用于表达式、常量或 register 类型的变量

一元运算符 * 是间接寻址或间接引用运算符。作用于指针时将访问所指向的对象
一元运算符的优先级比算术运算符的优先级高

指针只能指向某种特定类型的对象，每个指针都必须指向某种特定的数据类型（一个例外是 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）

### Pointers and Function Arguments

由于 C 语言是以传值的方式将参数传递给被调用函数，因此，被调用函数不能直接修改主调函数中变量的值

```C
void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
}

swap(a, b);
```

上述语句无法达到交换变量的目的，应在主调函数中将要交换变量的指针传递给被调用函数：

```C
void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp
}

swap(&a, &b);
```

### Pointers and Arrays(指针和数组)

通过数组下标所能完成的任何操作都可以通过指针来实现。一般来说，用指针编写的程序比用数组下标的执行速度更快
声明
int a[10];
定义了一个长度为10的数组 a，它是由10个对象组成的集合，这 10 个对象存储在相邻的内存区域中
a[i] 表示数组的第 i 个元素

```C
int *pa;        // 声明整型指针
pa = &a[1];     // 将指针指向数组 a 的第 1 个元素
x = *pa;        // 把数组元素 a[1] 中的内容复制到变量 x 中
```

如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个元素，如果指针pa指向 a[0]，那么*(pa+i) 引用的是数组的元素 a[i] 的内容
无论数组中元素的类型或长度是什么，指针加1就意味着 pa+1 指向 pa 所指向的对象的下一个对象
根据定义，数组类型的变量或表达式的值是该数组第 0 个元素的地址，所以 pa=&a[0] 等价于 pa = a
对数组元素 a[i] 的引用也可以写成 *(a+i) 的形式，a+i 是 a 之后第 i 个元素的地址
简而言之，一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现
数组名和指针的区别在于，指针是一个变量，因此语句 pa = a 和 pa++ 都是合法的。但数组名不是变量，类似形式的操作是非法的
当把数组名传递给一个函数时，实际传递的是该数组第一个元素的地址。在被调用函数中，该参数是一个局部变量，因此数组名参数必须是一个指针

```C
int strlen(char *s)
{
    int n=0;
    while(*s != '\0')
    {
        s++;
        n++;
    }
    return n;
}
```

因为 s 是一个指针，所以其执行自增运算是合法的，并且不会影响到主调函数中的字符串
在函数定义中，形式参数 char s[] 和 char *s 是等价的，通常更习惯于使用后一种形式，其更直观地表明了该参数是一个指针
也可以将指向子数组起始位置的指针传递给函数，这样就将数组的一部分传递给了函数
例如，f(&a[2]) 和 f(a+2)

### Address Arithmetic(地址算术运算)

C 语言中的地址算术运算方法是一致且有规律的，将指针、数组和地址的算术运算集成在了一起

### Pointers to Functions(指向函数的指针)

在 C 语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数一起作为函数的返回值等等

## Structures

结构是一个或多个变量的集合，这些变量可能是不同的类型，为了处理的方便而将这些变量组织在一个名字之下

### Basics of Structures

```C
struct point {
    int x;
    int y;
}
```

关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字 struct 后面的名字是可选的，称为结构标记
结构中定义的变量称为成员。结构成员、结构标记和普通变量（即非成员变量）可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对其进行区分
不同结构体中的成员可以使用相同的名字
struct 声明定义了一种数据类型。在标志结构成员变量表结束的花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的

struct { ... } x, y, z;

这种结构声明与基本类型的声明一样，将为声明的变量分配存储空间。如果声明结构中带有标记，在定义结构实例时可以使用该标记定义

struct point pt;

结构的初始化可以在定义的后面使用处值表进行。处值表中每个成员对应的初值必须是常量表达式

struct point maxpt = { 320, 200 };

自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构的函数进行初始化

结构成员运算符"."将结构名与成员名连接起来

结构名.成员

printf("%d, %d", pt.x, pt.y);

结构可以嵌套

### Structures and Functions

结构的合法操作只有几种：作为一个整体赋值和赋值，通过 & 运算符取地址，访问其成员。其中，复制和赋值包括向函数传递参数以及从函数返回值
结构之间不可进行比较。可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化

### typedef(类型定义)

C 语言提供了一个称为 typedef 的功能，用来创建新的数据类型名，例如

typedef int Length

将 Length 定义为与 int 具有同等意义的名字。类型 Length 可用于类型声明、类型转换等

```C

```

typedef 声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名字而已
实际上， typedef 类似于 #define 语句，但由于 typedef 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力

typedef int (*PFI)(char *, char *);

该语句定义了类型PFI是“一个指向函数的指针，该函数具有两个 char * 类型的参数，返回值类型为 int”

除了表达方式更简洁外，使用 typedef 可以使程序参数化，以提高程序的可移植性。如果 typedef 声明的数据类型同机器有关，移植到其他机器上时，只需要修改 typedef 类型定义就可以了
对于各种不同大小的整型值来说，都使用 typedef 定义的类型名，然后，分别为各个不同的宿主机选择彝族合适的 short、int和long类型大小即可

## Input and Output

## The UNIX System Interface(UNIX系统接口)

UNIX操作系统通过一系列的**系统调用**提供服务，这些系统调用实际上是操作系统内的函数，它们可以被用户程序调用

### File Descriptors(文件描述符)

在UNIX操作系统中，所有的外围设备都被看作是文件系统中的文件，因此，所有的输入/输出都要通过读文件或写文件完成。也就是说，通过一个单一的接口就可以处理外围设备和程序之间的所有通信

通常情况下，在读或写文件之前，必须通知系统，该过程称为*打开*文件。如果是写一个文件，则可能需要创建该文件，也可能需要丢弃该文件中原先存在的内容。系统会检查你的权限，如果一切正常，操作系统将向程序返回一个小的非负整数，称为文件描述符（file descriptor）
任何时候对文件的输入/输出都是通过文件描述符标识文件，而不是通过文件名标识文件
系统负责维护已打开文件的所有信息，用户程序只能通过文件描述符引用文件

因为大多数的输入/输出是通过键盘和显示器来实现的，为方表起见，UNIX对此做了特别的安排
当命令解释程序（shell）运行一个程序的时候，它将打开3个文件，对应的文件描述符分别为0、1、2，依次表示标准输入、标准输出和标准错误
如果程序从文件0中读，对1和2进行写，就可以进行输入/输出而不必关心打开文件的问题

通过 < 和 > 重定向程序的I/O：

grop <输入文件名>输出文件名

这种情况下，shell把文件描述符0和1的默认赋值改变为指定的文件。通常，文件描述符2仍与显示器相关联
与管道相关的输入/输出也有类似的特性
在任何情况下，文件赋值的改变都不是由程序完成的，而是由shell完成的。只要程序使用文件0作为输入，文件1和2作为输出，它就不会知道程序的输入从哪里来，并输出到哪里去

#### 临时文件

```C
FILE *tmpfile(void);
char *tmpnam(char *s);
```

tmpfile 函数创建一个临时文件（用"wb+"模式打开），该临时文件将一直存在，除非关闭
它或程序终止。tmpfile 函数的调用会返回文件指针，此指针可以用于稍后访问该文件。如果创建文件失败，tmpfile 函数会返回空指针

虽然 tmpfile 函数很易于使用，但它有两个缺点：(1) 无法知道 tmpfile 函数创建的文
件名是什么；(2) 无法在以后使文件变为永久的。如果这些缺陷导致了问题，备选的解决方案就
是用 fopen 函数产生临时文件。当然，我们不希望此文件拥有和前面已经存在的文件相同的名
字，因此需要一种方法来产生新的文件名。这也是 tmpnam 函数出现的原因。
tmpnam 函数为临时文件产生名字。如果它的实际参数是空指针，那么 tmpnam 函数会把文
件名存储到一个静态变量中，并且返回指向此变量的指针：

char *filename;
...
filename = tmpnam(NULL); /* creates a temporary file name */ 

否则，tmpnam 函数会把文件名复制到程序员提供的字符数组中：

char filename[L_tmpnam];
...
tmpnam(filename); /* creates a temporary file name */

在后一种情况下，tmpnam 函数也会返回指向数组第一个字符的指针。L_tmpnam 是<stdio.h>
中的一个宏，它指明了保存临时文件名的字符数组的长度

### Low Level I/O - Read and Write

输入与输出是通过 read 和 write 系统调用实现的
在 C 语言中可以通过函数 read 和 write 访问这两个系统调用
这两个函数中，第一个参数是文件描述符，第二个参数是程序中存放读或写的数据的字符数组，第三个参数是要传输的字节数

```C
int n_read = read(int fd, char *buf, int n);
int n_written = write(int fd, char *buf, int n);
```

每个调用返回实际传输的字节数。在读文件时，函数的返回值可能会小于请求的字节数。如果返回值为0，则表示已到达文件的结尾；如果返回值为-1，则表示发生了某种错误
在写文件时，返回值是实际写入的字节数。如果返回值与请求写入的字节数不相等，则说明发生了错误

在一次调用中，读出或写入的数据的字节数可以为任意大小。最常用的值为1，即每次读出或写入1个字符（无缓冲），或是类似于1024或4096这样的与外围设备的物理块大小相应的值。用更大的值调用该函数可以获得更高的效率

### A Storage Allocator

malloc 并不是从一个在编译时就确定的固定大小的数组中分配存储空间，而是在需要时向操作系统申请空间
因为程序中的某些地方可能不通过 malloc 调用申请空间（通过其他方式申请空间），所以，malloc 管理的空间不一定是连续的
空间存储空间以空闲块链表的方式组织，每个块包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针
这些块按照存储地址的升序组织，最后一块（最高地址）指向第一块

![](./image/malloc.png)

当有申请请求时，malloc将扫描空闲块链表，知道找到一个足够大的块为止。该算法称为“首次适应”（first fit）；与之相对的算法是“最佳适应”（best fit），它寻找满足条件的最小块
如果该块恰好与请求的大小相符合，则将它从链表中移走并返回给用户
如果该块太大，则将它分为两部分：大小合适的块返回给用户，剩下的部分留在空闲块链表中
如果找不到一个足够大的块，则向操作系统申请一个大块并加入到空闲链表中

释放过程也是首先搜索空闲块链表，以找到可以插入被释放块的合适位置
如果与被释放块相邻的任一边是一个空闲块，则将这两个块合成一个更大的块
因为空闲块链表是以地址的递增顺序链接在一起，所以很容易判断相邻的块是否空闲

确保由 malloc 函数返回的存储空间满足将要保存的对象的对齐要求
每个特定的机器都有一个最受限的类型：如果最受限的类型可以存储在某个特定的地址中，则其他所有的类型也可以存放在此地址中

空闲块包含一个指向链表中下一个块的指针、一个块大小的记录和一个指向空闲空间本身的指针
位于块开始处的控制信息称为“头部”。为了简化块的对齐，所有块的大小都必须是头部大小的整数倍，且头部已正确地对齐
这是通过一个联合实现的，该联合包含所需的头部结构以及一个对齐要求最受限的类型的实例

## Reference Manual


## 底层程序设计

### 位运算符

#### 用位运算符访问位

- 位的设置

i |= 1 << j; // set bit j

- 位的清除

i &= ~(1 << j) // clear bit j

- 位的测试

if (i & 1 << j) // test bit j

#### volatile 类型限定符

在一些计算机中，一部分内存空间是“易变”的，保存在这种内存空间的值可能会在程序
运行期间发生改变，即使程序自身并未试图存放新值。例如，一些内存空间可能被用于保存直
接来自输入设备的数据。

volatile 类型限定符使我们可以通知编译器，程序中的某些数据是“易变”的。volatile
限定符通常用于指向易变内存空间的指针的声明中：

volatile BYTE *p; /* p will point to a volatile byte */

为了解为什么要使用 volatile，假设指针 p 指向的内存空间用于存放用户通过键盘输入
的最近一个字符。这个内存空间是易变的：用户每输入一个新字符，这里的值都会发生改变。

### 对象的对齐

受硬件布线的限制，或者为了提高存储器访问效率，要求特定类型的对象在存储器里的位
置只能开始于某些特定的字节地址，而这些字节地址都是某个数值 N 的特定倍数（以不超过
实际的存储空间为限），这称为对齐（alignment）。更进一步，我们称那个对象是对齐于 N 的。

对于完整的对象类型来说，“对齐”限制了它在存储器中可以被分配到的地址。实际上，这
是一个由 C 实现定义的整数值。

### 对齐运算符 _Alignof

从 C11 开始，可以用运算符 _Alignof 得到指定类型的对齐值。_Alignof 运算符的操作数
要求是用括号括起来的类型名：
[_Alignof 表达式] _Alignof(类型名)
_Alignof 运算符的结果类型是 size_t。注意，这个运算符不能应用于函数类型和不完整
的对象类型。如果应用于数组，则返回元素类型的对齐需求。下面是一个应用_Alignof 运算符
的例子：

```C
# include <stdio.h> 
void f (void) 
{ 
    printf("%zu, %zu, %zu, %zu\n", 
        _Alignof (char), 
        _Alignof (int), 
        _Alignof (int [33]), 
        _Alignof (struct {char c; float f;}));
}
```
